# 考试题目

## HTML



## CSS



## JS



## Java

1. 对Java语言来说，下面的变量名命令正确且有意义的是( )

   A.name  B. aaa  C. 123name  D. -name

   **答案：** A 

   **考察点：** 考察学生对Java变量的掌握

2. 在类方法中声明的变量，属于(     )。

   A.局部变量    B.成员变量  C.方法参数    D.异常处理参数

   **答案：** B

   **考察点：** 考察局部变量和成员变量的区别

3. 关于被私有访问控制符private修饰的成员变量，以下说法正确的是(    )

   A. 可以被三种类所引用：该类自身、与它在同一个包中的其他类、在其他包中的该类的子类

   B. 可以被两种类访问和引用：该类本身、该类的所有子类

   C. 只能被该类自身所访问和修改

   D. 只能被同一个包中的类访问

   **答案：** C

   **考察点：**  考察访问修饰符的作用

4. 下面程序的运行结果是：

   ```java
   String str1 = "hello";
   String str2 = "he" + new String("llo");
   System.err.println(str1 == str2);
   ```

   A. true  B. false

   **答案：** B

   **考察点：**  考察==的作用

5. 下列说法正确的有（）

   A． class中的constructor不可省略

   B． constructor必须与class同名，但方法不能与class同名

   C． constructor在一个对象被new时执行

   D．一个class只能定义一个constructor

   **答案：** C

   **考察点**：普通的类方法是可以和类名同名的，和构造方法唯一的区分就是，构造方法没有返回值。

6. 下面哪个流类属于面向字符的输入流(  )

   A. BufferedWriter           B. FileInputStream          C. ObjectInputStream          D. InputStreamReader

    **答案**：D

   **考察点：** 字节流和字符流的区别

7. 下列哪种异常是检查型异常，需要在编写程序时声明 （）

   A. NullPointerException        B. ClassCastException      C. FileNotFoundException       D. IndexOutOfBoundsException 

   **答案**：C

   **考察点：** 异常的分类

8. 阅读Shape和Circle两个类的定义。在序列化一个Circle的对象circle到文件时，下面哪个字段会被保存到文件中？ (  )

   ```java
   class Shape {
   
          public String name;
   
   }
   
   class Circle extends Shape implements Serializable{
   
          private float radius;
   
          transient int color;
   
          public static String type = "Circle";
   
   }
   ```

   A. name   B. radius  C. color D. type

   **答案**：B

   **考察点**：序列化的基本知识

9. 在多线程程序设计中，如果采用继承Thread类的方式创建线程，则需要重写Thread类的()方法

   A. Start    B. local    C. Interrupt  D. run

   **答案： ** D

   **考察点**： 多线程的基本知识

10. 下面程序输出结果是()

    ```java
    Short s1 = 1;
    Short s2 = s1;
    s1++;
    System.out.println(s1 == s2);
    ```

    A. true  B. false

    **答案：** B

    **考察点**： 自动拆箱和装箱机制 

    

    **中等难度题目**(多选题)：

11. 下面哪些属于Java创建对象的方式？()

    A. new 语句

    B. 运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法

    C. 调用对象的clone()方法

    D. 运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法

    **答案：** ABCD

    **考察点：** 构建对象的几种方式

12. 下列哪些叙述是正确的（）

    A.final类可以有子类。

    B.abstract类中只可以有abstract方法。

    C.abstract类中可以有非abstract方法，但该方法不可以用final修饰。

    D.不可以同时用final和abstract修饰同一个方法。

    E.允许使用static修饰abstract方法。

    F. abstract类的子类必须是非abstract类

    **答案：** D

13. 阅读以下代码:

    ```java
    public class Food {
        String name;
    }
    public class Fruit extends Food {
    }
    public class Meat extends Food {
    }
    public class Apple extends Fruit {
    }
    ```

    有下面集合

    ```java
    List<? extends Food> foodList = new ArrayList<>();
    List<? super Fruit> fruitList = new ArrayList<>();
    ```

    下面哪些操作正确的是：()

    A. foodList.add(new Apple()); 

    B. foodList.add(new Meat());

    C. fruitList.add(new Apple());

    D. fruitList.add(new Food());

    **答案：** C

    **考察点：** 泛型的通配符

14. 下面代码运用了那些设计模式：

    ```java
    public abstract class Transport {
        protected String name;
        
        public Transport(String name) {
            this.name = name;
        }
        
        public String getName() {
            return name;
        }
        
        public abstract int getPrice();
    }
    
    public class Train extends Transport {
        
        public Train(String name) {
            super(name);
        }
        
        @Override
        public int getPrice() {
            return 400;
        }
    }
    
    public class AirPlane extends Transport {
        public AirPlane(String name) {
            super(name);
        }
        
        @Override
        public int getPrice() {
            return 1000;
        }
    }
    
    public class Bus extends Transport {
        public Bus(String name) {
            super(name);
        }
        
        @Override
        public int getPrice() {
            return 300;
        }
    }
    
    public class Context {
        private List<Transport> allTransports = new ArrayList<>();
        
        public Context() {
            this.allTransports.add(new Bus("大巴车"));
            this.allTransports.add(new AirPlane("飞机"));
            this.allTransports.add(new SelfDriving("自驾"));
            this.allTransports.add(new Train("火车"));
        }
        
        public List<Transport> getChoseTransport(int money) {
            return allTransports.stream().filter(transport -> transport.getPrice() <= money).collect(Collectors.toList());
        }
    }
    ```

    A. 单利模式  B. 策略模式  C. 工厂模式 D.模板方法

    **答案：** B

    **考察点：** 设计模式的熟练程度

15. 阅读下面代码：

    ```java
    public class Food {
        private String name;
        private int price;
        
        public Food(String name, int price) {
            this.name = name;
            this.price = price;
        }
        
        public String getName() {
            return name;
        }
        
        public void setName(String name) {
            this.name = name;
        }
        
        public int getPrice() {
            return price;
        }
        
        public void setPrice(int price) {
            this.price = price;
        }
    }
    ```

    那么下面代码的运行结果是：

    ```java
    public class Test {
        public static void main(String[] args) {
            List<Food> foodList = new ArrayList<>();
        
            foodList.add(new Food("大盘鸡", 30));
            foodList.add(new Food("沙拉", 20));
            foodList.add(new Food("冰淇淋", 10));
            foodList.add(new Food("佛跳墙", 15));
            foodList.add(new Food("热干面", 5));
            foodList.add(new Food("兰州拉面", 15));
        
            foodList.stream().filter(food -> food.getName() != "佛跳墙").map(Food::getPrice).mapToInt(Integer::intValue).average().ifPresent(System.out::println);
        }
    }
    ```

    A. 15  B. 30  C. 16  D. 没有输出

    **答案**：C

    **考察点：** Java 8 stream的操作

## DB

